// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (cargo-witgen v0.0.2) 

// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (cargo-witgen v0.0.2) 

record storage-balance-bounds {
    min: u128,
	max: option<u128>
}

///  StorageUsage is used to count the amount of storage used by a contract.
type storage-usage = u64

///  Balance is a type for storing amounts of tokens, specified in yoctoNEAR.
type balance = u128

///  Represents the amount of NEAR tokens in "gas units" which are used to fund transactions.
type gas = u64

record fungible-token-metadata {
    spec: string,
	name: string,
	symbol: string,
	icon: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>,
	decimals: u8
}

///  In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
record token {
    token-id: token-id,
	owner-id: account-id,
	metadata: option<token-metadata>,
	approved-account-ids: option<list<tuple<account-id,u64>>>
}

///  base64 string.
type base64-vec-u8 = string

///  Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
type token-id = string

///  Raw type for duration in nanoseconds
type duration = u64

record storage-balance {
    total: u128,
	available: u128
}

type u128 = string

type wrapped-duration = string

///  Metadata on the individual token level.
record token-metadata {
    title: option<string>,
	description: option<string>,
	media: option<string>,
	media-hash: option<base64-vec-u8>,
	copies: option<u64>,
	issued-at: option<string>,
	expires-at: option<string>,
	starts-at: option<string>,
	updated-at: option<string>,
	extra: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>
}

///  Public key in a binary format with base58 string serialization with human-readable curve.
///  The key types currently supported are `secp256k1` and `ed25519`.
/// 
///  Ed25519 public keys accepted are 32 bytes and secp256k1 keys are the uncompressed 64 format.
type public-key = string

type account-id = string

///  Metadata for the NFT contract itself.
record nft-contract-metadata {
    spec: string,
	name: string,
	symbol: string,
	icon: option<string>,
	base-uri: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>
}

///  Raw type for timestamp in nanoseconds
type timestamp = u64



nft-total-supply: function() -> u128


nft-tokens: function(from-index: option<u128>, limit: option<u64>) -> list<token>


nft-token: function(token-id: token-id) -> option<token>


///  change
nft-approve: function(token-id: token-id, account-id: account-id, msg: option<string>)

///  change
nft-transfer-call: function(receiver-id: account-id, token-id: token-id, approval-id: option<u64>, memo: option<string>, msg: string)

///  Initializes the contract owned by `owner_id` with
///  default metadata (for example purposes only).
///  change
new-default-meta: function(owner-id: account-id)

///  change
nft-transfer: function(receiver-id: account-id, token-id: token-id, approval-id: option<u64>, memo: option<string>)

///  Mint a new token with ID=`token_id` belonging to `token_owner_id`.
/// 
///  Since this example implements metadata, it also requires per-token metadata to be provided
///  in this call. `self.tokens.mint` will also require it to be Some, since
///  `StorageKey::TokenMetadata` was provided at initialization.
/// 
///  `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
///  initialization call to `new`.
///  change
nft-mint: function(token-id: token-id, token-owner-id: account-id, token-metadata: token-metadata) -> token


///  change
nft-revoke-all: function(token-id: token-id)

///  change
nft-revoke: function(token-id: token-id, account-id: account-id)

nft-metadata: function() -> nft-contract-metadata


nft-is-approved: function(token-id: token-id, approved-account-id: account-id, approval-id: option<u64>) -> bool


nft-tokens-for-owner: function(account-id: account-id, from-index: option<u128>, limit: option<u64>) -> list<token>


nft-supply-for-owner: function(account-id: account-id) -> u128


///  change
new: function(owner-id: account-id, metadata: nft-contract-metadata)

