// This is a generated file by witgen (https://github.com/bnjjj/witgen), please do not edit yourself, you can generate a new one thanks to cargo witgen generate command. (cargo-witgen v0.6.0) 

///  Mask which validators participated in multi sign.
type validator-mask = list<bool>

///  StorageUsage is used to count the amount of storage used by a contract.
type storage-usage = u64

///  Height of the block.
type block-height = u64

///  Nonce for transactions.
type nonce = u64

///  Balance is a type for storing amounts of tokens, specified in yoctoNEAR.
type balance = u128

///  Number of shards in current group.
type num-shards = u64

type promise-id = list<u64>

///  Height of the epoch.
type epoch-height = u64

///  In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
record token {
    token-id: token-id,
	owner-id: account-id,
	metadata: option<token-metadata>,
	approved-account-ids: option<list<tuple<account-id,u64>>>
}

///  Shard index, from 0 to NUM_SHARDS - 1.
type shard-id = u64

///  Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
type token-id = string

///  Account identifier. This is the human readable utf8 string which is used internally to index
///  accounts on the network and their respective state.
/// 
///  Because these IDs have to be validated, they have to be converted from a string
///  with [`FromStr`] or [`TryFrom`] a compatible type. To skip validation on initialization,
///  [`AccountId::new_unchecked`] can be used.
/// 
///  # Examples
///  ```
///  use near_sdk::AccountId;
///  use std::convert::{TryFrom, TryInto};
/// 
///  // `FromStr` conversion
///  let alice: AccountId = "alice.near".parse().unwrap();
///  assert!("invalid.".parse::<AccountId>().is_err());
/// 
///  let alice_string = "alice".to_string();
/// 
///  // From string with validation
///  let alice = AccountId::try_from(alice_string.clone()).unwrap();
///  let alice: AccountId = alice_string.try_into().unwrap();
/// 
///  // Initialize without validating
///  let alice_unchecked = AccountId::new_unchecked("alice".to_string());
///  assert_eq!(alice, alice_unchecked);
///  ```
/// 
///  [`FromStr`]: std::str::FromStr
type account-id = tuple<string>

// type i128 = tuple<i128>

///  StorageUsageChange is used to count the storage usage within a single contract call.
type storage-usage-change = s64

type u128 = string

///  Validator identifier in current group.
type validator-id = u64

///  Block height delta that measures the difference between `BlockHeight`s.
type block-height-delta = u64

///  Number of seats of validators (block producer or hidden ones) in current group (settlement).
type num-seats = u64

///  Metadata on the individual token level.
record token-metadata {
    title: option<string>,
	description: option<string>,
	media: option<string>,
	media-hash: option<base64-vec-u8>,
	copies: option<u64>,
	issued-at: option<string>,
	expires-at: option<string>,
	starts-at: option<string>,
	updated-at: option<string>,
	extra: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>
}

///  Number of blocks in current group.
type num-blocks = u64

///  Metadata for the NFT contract itself.
record nft-contract-metadata {
    spec: string,
	name: string,
	symbol: string,
	icon: option<string>,
	base-uri: option<string>,
	reference: option<string>,
	reference-hash: option<base64-vec-u8>
}

type i64 = tuple<s64>

///  Helper class to serialize/deserialize `Vec<u8>` to base64 string.
type base64-vec-u8 = tuple<list<u8>>
